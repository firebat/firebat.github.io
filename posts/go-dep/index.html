<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Go依赖管理 | firebat</title>
<link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css></head><body><nav><ul class=menu><li><a href=/>Home</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about>About</a></li><li><a href=/index.xml>Subscribe</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>Go依赖管理</span></h1><h2 class=date>2023/02/01</h2></div><main><p>最初起源于Google公司内部的代码依赖管理方式：所有源代码放在一个巨大的仓库中，直接使用路径引用，无包版本控制，无第三方仓库，从当前分支中构建所有内容。</p><ul><li>添加依赖意味着将仓库代码克隆到本地<code>$GOPATH</code>中缓存，版本指向克隆时的主分支。</li></ul><p>2017年Russ Cox 在GopherCon发表<a href=https://go.dev/blog/toward-go2>Toward Go2</a>后，Go1.11发布，兼容性作为Go语言演化的第一考虑。一个模块是一组相关的Go包集合，被当做一个独立的单元进行统一版本管理，为了<code>可复制构建</code>和<code>新旧兼容</code>。</p><ul><li><code>1.11</code>版本引入Go Modules，保持与Go1兼容，默认为<code>GO111MODULE=off</code></li><li><code>1.13</code>版本默认<code>GO111MODULE=auto</code> 检测是否包含go.mod，如果有则启用module模式</li><li><code>1.14</code>版本GoMod可供生产使用，鼓励用户从其他以来管理系统迁移到Go Mod</li><li><code>1.16</code>版本默认<code>GO111MODULE=on</code></li></ul><h1 id=版本号>版本号</h1><p>默认版本号结构为<code>v&lt;major>.&lt;minor>.&lt;patch>[-meta]</code> 参考<a href=https://semver.org/spec/v2.0.0.html>Semantic Versioning 2.0.0</a></p><ul><li><code>Major</code> 发布不兼容版本时递增，且Minor, Patch置为0</li><li><code>Minor</code> 发布向后兼容的更改时递增，且Patch置为0</li><li><code>Patch</code> 公共接口不做修改，仅仅是Bug修复或部分优化时递增</li><li><code>-pre</code> 预发版，如<code>v1.2.3</code>之前发布<code>v1.2.3-pre</code></li><li><code>+incompatible</code> 构建元数据中保留的版本，标识主版本号升级到2以上（第一个非兼容版本）时使用。参考 <a href=https://go.dev/ref/mod#non-module-compat>Compatibility with non-module</a></li></ul><h2 id=伪版本>伪版本</h2><p>通过时间戳/提交哈希，固化一个非稳定版本(如<code>0.x.x</code>, <code>-pre</code>) 参考 <a href=https://go.dev/ref/mod#glos-pseudo-version>Pseudo Version</a>。慎重依赖非稳定版本，避免重复构建失效。</p><pre tabindex=0><code>vx.y.z-yyyymmddhhmmss-abcdef
</code></pre><h2 id=版本路径>版本路径</h2><p>当模块出现一次非兼容升级时，路径必须有一个类似<code>/v2</code>的后缀。以遵循<code>同路径必须兼容</code>原则。</p><pre tabindex=0><code>example.com/mod =&gt; exmaple.com/mod/v2
</code></pre><h2 id=版本选择>版本选择</h2><ul><li>如果go.mod中已标记版本号，使用<code>固定版本</code></li><li>未指定版本，<code>import</code>时导入<code>最新版本</code></li><li>某个模块被多个模块间接依赖，使用该模块的<code>最小可用版本</code></li></ul><pre tabindex=0><code>M v1.0.0 -&gt; module A
                      module X(M v1.1.1) // 确保A/B模块同时兼容
M v1.1.1 -&gt; module B
</code></pre><h1 id=包管理>包管理</h1><ul><li><code>go mod init &lt;module></code> 初始化模块</li><li><code>go get &lt;module></code> 添加、升级最新版</li><li><code>go get &lt;module>@&lt;version></code> 添加、升级、降级指定版</li><li><code>go get &lt;module>@none</code> 删除模块，并将需要它的模块降级</li><li><code>go get -u &lt;module></code> 升级到minor, patch到最新可用版本</li><li><code>go mod tidy</code> 自动清理未使用的模块</li><li><code>go mod graph</code> 模块依赖信息</li><li><code>go mod why &lt;module></code> 模块依赖路径</li><li><code>go list -m all</code> 列出全部模块</li></ul><h1 id=参考>参考</h1><ul><li><a href=https://research.swtch.com/vgo>Go & Versioning</a></li><li><a href=https://research.swtch.com/vgo-principles>The Principles of Versioning in Go</a> by <code>Russ Cox</code>, Go团队Leader</li></ul></main><footer><hr>© <a href=https://github.com/firebat>firebat</a> 2015 &ndash; 2025</footer></body></html>