<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on firebat</title><link>https://firebat.github.io/posts/</link><description>Recent content in Posts on firebat</description><generator>Hugo</generator><language>en</language><lastBuildDate>Fri, 28 Feb 2025 04:04:38 -0400</lastBuildDate><atom:link href="https://firebat.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>浅析Voip原理</title><link>https://firebat.github.io/posts/voip/</link><pubDate>Fri, 28 Feb 2025 04:04:38 -0400</pubDate><guid>https://firebat.github.io/posts/voip/</guid><description>&lt;p>&lt;img src="./images/webrtc-comprehensive.png" alt="WebRTC">
P2P技术的发展，产生了各种网络共享下载的应用，如Napster、Gnutella；音视频编码算法的进步、硬件性能的提升以及移动互联网的发展，在我们身边诞生出形形色色的网络应用，如网络电话、网络会议、网络直播等，同时也带来了各种商业上的成功。&lt;/p>
&lt;ul>
&lt;li>Skype 2003年诞生的一款即时通信应用软件，可通过互联网进行语音和视频通话，2011年微软85亿美元收购。&lt;/li>
&lt;li>FaceTime 2010年苹果公司的一种视频通话应用软件，采用多种开放协议，ACC与H.264的音视频编码。&lt;/li>
&lt;li>WebRTC 2011年Google发起的开源实时通讯解决方案，支持浏览器集成。&lt;/li>
&lt;/ul>
&lt;p>作为互联网从业的研发人员，我们有必要了解一下，这一切是怎么发生的，其内部是如何实现的。&lt;/p>
&lt;h1 id="网络">网络&lt;/h1>
&lt;p>因为互联网的快速发展，联网设备数量远超设计者的最初设想，整个IPv4的地址范围不够用，因此引入了NAT技术。NAT（Net Address Translate）网络地址转换，简单来说就是在路由层记录私有网络和公有网络的IP映射关系，并进行IP数据包的修改，实现了公网IP复用的技术。
&lt;img src="./images/NAT_Concept-en.svg" alt="NAT">&lt;/p>
&lt;p>根据路由器对私网IP端口到公网IP端口的映射方式，RFC3489中将NAT分为四种类型&lt;/p>
&lt;ul>
&lt;li>Full Cone NAT（全锥型），同一内部IP端口发出的请求，被映射到相同的外部IP端口；任何外部主机通过向映射的地址发送报文，实现与内部主机通信。&lt;/li>
&lt;li>Restricted Cone NAT（受限锥型），发出同上；当且仅当内部主机之前向公网主机发送过报文，公网主机才能与其通信。&lt;/li>
&lt;li>Port Restricted Cone NAT（端口受限锥型）发出同上；限制条件包括端口。&lt;/li>
&lt;li>Symmetric NAT（对称型）所有内部IP端口向特定目的IP端口发出的请求，都被映射成同一个IP和端口。只有接收到数据的公网主机才能反向与内部主机通信。
&lt;img src="./images/nat-type.png" alt="NAT类型">&lt;/li>
&lt;/ul>
&lt;h1 id="类型检测">类型检测&lt;/h1>
&lt;p>要检测当前主机所在的NAT类型，需要在云端部署一个服务，包含两个IP和端口
&lt;img src="./images/detect-no-nat.jpg" alt="无NAT">&lt;/p>
&lt;ul>
&lt;li>客户端向服务器发送请求，服务器将观察到的地址响应给客户端&lt;/li>
&lt;li>如果响应中的地址与发送地址一致，说明客户端在公网，没有NAT。
&lt;img src="./images/detect-cone-sym.jpg" alt="对称性">&lt;/li>
&lt;li>客户端向服务端第二个IP地址再发送一个请求&lt;/li>
&lt;li>如果两次响应中的公网地址不一致，说明是对称型
&lt;img src="./images/detect-cone-full.jpg" alt="全锥型">&lt;/li>
&lt;li>客户端向服务器第一个IP地址发送请求，服务端用另一个IP地址返回&lt;/li>
&lt;li>如果可以收到，说明是全锥型
&lt;img src="./images/detect-cone-restricted.jpg" alt="受限锥型">&lt;/li>
&lt;li>客户端向服务器再发送一个请求，服务器用同一IP的第二个端口响应&lt;/li>
&lt;li>如果可以收到，说明是受限锥型；否则为端口受限锥型。&lt;/li>
&lt;/ul>
&lt;h1 id="nat穿透">NAT穿透&lt;/h1>
&lt;p>NAT技术解决了IPv4不够用的问题，同时也导致TCP/IP通信困难，外部主机无法主动与内部主机通信，所有服务不得不采用C/S架构，导致高额的带宽成本。为了节约网络带宽成本，将客户端也作为资源提供方减少对服务的访问，因此产生了P2P技术。即Peer-to-Peer，点对点技术，其中最关键的技术之一，就是NAT设备穿透，俗称打洞。&lt;/p>
&lt;h2 id="反向链接">反向链接&lt;/h2>
&lt;p>通信双方只有一个节点位于NAT中
&lt;img src="./images/nat-reversal-connection.jpg" alt="">&lt;/p>
&lt;ul>
&lt;li>A请求B时，可以直接发起&lt;/li>
&lt;li>B请求A时，通过S转发给A一个连接请求，A再发起请求&lt;/li>
&lt;/ul>
&lt;h2 id="简单场景">简单场景&lt;/h2>
&lt;p>双方位于同一个NAT设备之后
&lt;img src="./images/hole-punch-simple.jpg" alt="">&lt;/p>
&lt;ul>
&lt;li>A与B分别与S建立连接，S记录下双方的内网信息，以及自己观察到的公网信息；&lt;/li>
&lt;li>A向S发起连接B的请求；S分别向双方发送对方的公网和内网地址；&lt;/li>
&lt;li>A和B收到信息后，同时向对方发起连接；推荐优先使用内网地址，直接通过交换机通信，速度快。也可以使用公网地址，需要网关支持Hairpin技术。&lt;/li>
&lt;/ul>
&lt;h2 id="普遍场景">普遍场景&lt;/h2>
&lt;p>双方位于不同的NAT设备之后
&lt;img src="./images/hole-punch-normal.jpg" alt="">&lt;/p>
&lt;ul>
&lt;li>A与B分别与S建立连接，S记录下双方的内网信息，以及自己观察到的公网信息；&lt;/li>
&lt;li>A向S发起连接B的请求；S分别向双方发送对方的公网和内网地址；&lt;/li>
&lt;li>A和B的同时使用对方的公网地址发送数据包&lt;/li>
&lt;/ul>
&lt;h3 id="双方为锥型">双方为锥型&lt;/h3>
&lt;p>&lt;img src="./images/punch-cone.png" alt="">&lt;/p>
&lt;ul>
&lt;li>A向B发送打洞包建立映射&lt;/li>
&lt;li>B向A发送打洞包建立映射&lt;/li>
&lt;li>打洞成功&lt;/li>
&lt;/ul>
&lt;h3 id="对称型和普通锥形全锥型受限锥型">对称型和普通锥形（全锥型、受限锥型）&lt;/h3>
&lt;p>&lt;img src="./images/punch-normal.png" alt="">&lt;/p>
&lt;ul>
&lt;li>A使用PA2向B发送打洞包，建立映射&lt;/li>
&lt;li>B使用PB1向PA1发送打洞包，建立映射&lt;/li>
&lt;li>B通过PB1收到A的打洞包，根据对方的NAT类型，后续使用PA2与A连接&lt;/li>
&lt;li>打洞成功&lt;/li>
&lt;/ul>
&lt;h3 id="对称型和端口受限型">对称型和端口受限型&lt;/h3>
&lt;ul>
&lt;li>流程同上&lt;/li>
&lt;li>由于端口受限，B无法在PB1上接收PA2发来的打洞包&lt;/li>
&lt;li>打洞失败&lt;/li>
&lt;/ul>
&lt;h3 id="双方都是对称型">双方都是对称型&lt;/h3>
&lt;ul>
&lt;li>场景更严格，原理同上，无法打洞&lt;/li>
&lt;/ul>
&lt;p>判断网络是否能够打通，有一种简单的计算方法&lt;/p></description></item><item><title>RTOS实现原理</title><link>https://firebat.github.io/posts/rtos/</link><pubDate>Mon, 04 Dec 2023 00:00:00 -0800</pubDate><guid>https://firebat.github.io/posts/rtos/</guid><description>&lt;h1 id="目的">目的&lt;/h1>
&lt;p>为什么会有这篇文章？
首先是好奇。月亮为什么会有盈缺？苹果为什么会落下？烧开水的壶盖为什么会跳动？无线电为什么会传播？正是因为好奇，人类才从洞穴走向了宇宙深空。好奇心是人类的基本特征，是追求进步、推动创新的源动力。记得有一道经典的面试题：浏览器输入URL后会车发生了什么？同样，在我们生活之中有各种类似的问题，当用手机扫描共享单车完成支付后，锁是怎么打开的？当把燃气充值卡后插入表中，发生了什么？&lt;/p>
&lt;p>其次是有用。计算机归根结底是一门应用学科，当我们在准备掌握一门新技术时，总会想到一个问题：有什么用。掌握编程语言让我们知道如何编写逻辑，掌握数据结构有助于更好地组织逻辑，其中最重要且复杂的要数操作系统。每一位有想法的计算机专业学生，都把写一个编译器或操作系统作为自己的终极目标或专业能力试金石。比如Linus在1997年的硕士毕业论文，题目就是《Linux: A Portable Operating System》。但当我们真正深入操作系统时不免会遇到重重困难：要么是书厚、代码多、门槛高；又或是时代久远，各种硬件环境、工具链资料缺失，难以复现；又或者是从xv6或30天系列入手，学完后遇到另一个问题“有什么用”。而学习RTOS就很好的避开了上述问题，不仅代码量少上手容易，迅速理解操作系统的工作原理；又能紧跟时代，获取到最新的硬件和技术资料；而且还能和实际生活应用联系起来。比如北京在20年治理雾霾过程中的空气质量监测，疫情期间公共场合的人体温度红外识别；记得B站上看过一个纪录片，福岛核事故后续，几位退休人员组成的民间团体，拿着自制的辐射检测仪深入街道、学校、树林检测环境的危害程度，来标记安全的活动区域，令人印象深刻。&lt;/p>
&lt;h1 id="发展历程">发展历程&lt;/h1>
&lt;p>我们将从计算机发展史开始，快速理解各种词汇的含义，并进一步认识微控制器和RTOS在现代技术领域中的定位。&lt;/p>
&lt;ul>
&lt;li>1969年12月，CTC计算机终端公司是一家使用TTL制造8位处理器生产电传打印机的公司，位于德克萨斯州，由NASA前工程师Gus Roche和Phil Ray在1968年创立。在开发Datapoint 2200时，为了减少处理器尺寸和发热量，咨询Intel能否采用单芯片的方案。德州仪器的销售人员听说此事后，也争取到了这份订单。&lt;/li>
&lt;li>1971年6月，德州仪器率先公布TMX1795，第一款8位处理器，但由于空间浪费并未被采纳；而Intel的芯片直到年底才就绪，同样未被采纳；CTC采用开关电源解决了发热问题，并继续使用TTL制造处理器。&lt;/li>
&lt;li>1971年11月，Intel发布第一款4位单芯片处理器4004，又称MCS-4，主频108~740KHz，内部由四个集成电路（IC）组成，由Federico Faggin、Stan Mazor和Ted Hoff三位工程师设计，提供给日本公司Busicom用来生产电子计算器。通过让出6万美元的研发费用，Intel拥有了4004的所有权。&lt;/li>
&lt;li>1972年4月，Intel发布了8位处理器8008，又称MCS-8，频率0.5/0.8MHz，14位地址支持16KB内存、支持中断处理。由于当初CTC放弃该芯片时没有支付足够的研发费用，双方达成协议，Intel获得了芯片所有权以及CTC开发的指令集，并在两年后将其商业化，该指令集成为x86指令的基础。&lt;/li>
&lt;li>1974年3月，Motorola推出MC6800，以PDP-11的处理器为结构模板，时钟可达1~2MHz，16位地址可直接访问64KB内存。6月，惠普开发出基于6800的系统原型机；直到11月，M6800微机系统才投产。Motorola采用和8080同样的售价，高达360美元。由于工厂搬迁、裁员危机、以及公司对研发低成本处理器的消极态度，8月，研发人员Chuck Peddle和其他五名工程师离开后，加入了宾夕法尼亚州的MOS科技，该公司主要为德州仪器和雅达利做外包。&lt;/li>
&lt;li>1974年4月，Intel发布8080处理器，做为8008的扩展和增强，时钟频率达到2MHz，由于指令集的原因，实际处理速度不如6800，最初主要用于控制交通信号灯，但很快被用来生产计算机，并成为有史以来最成功的处理器之一。1975年1月，MITS采用8080生产出Altair 8800，成为世界上第一台微型计算机，拥有256字节RAM。在哈佛读书的Bill Gates和Paul Allen为其设计了BASIC编辑器。&lt;/li>
&lt;li>1974年12月，仙童（Fairchild）推出第一款单片机F8，包含一个8位CPU、64B RAM（其实是两片3850/3851)。&lt;/li>
&lt;li>1975年9月，MOS科技推出了6502，主频和6800一致，但拥有一条指令流水线，性能更好，售价仅25美元。同时为了帮助电子工程师制作电脑和设备，Peddle还研发了KIM-1开发板，拥有1KB内存。由于6502的出色表现，MOS科技被Commodore收购。由于价格低廉，性能出色，该处理器被广泛应用于家庭电脑、游戏机之中。&lt;/li>
&lt;li>1976年3月，Steve Wozniak和Steve Jos利用6502搭建出了Apple I的主板，并在4月1日成立Apple公司。&lt;/li>
&lt;li>1976年7月，Federico Faggin离开Intel成立了Zilog公司并发布Z80处理器，达到2.5MHz，与8080指令兼容。&lt;/li>
&lt;li>1976年9月，Intel推出8位单片机MCS-48系列，内部包含1KB ROM、64B RAM，用于制造电视遥控、键盘等。&lt;/li>
&lt;li>1977年10月，通用仪器（GI）公布了PIC1650单片机，包含512B ROM、32B RAM，用于扩展CP1600（GI和霍尼韦尔联合开发的16位处理器）的IO功能，后拆分成为Microchip公司。&lt;/li>
&lt;li>1978年6月，Intel推出第一款16位处理器 8086，主频4.43MHz，24位地址总线寻址范围达到1MB。&lt;/li>
&lt;li>1978年12月，Hermann Hauser和Chris Curry在英格兰剑桥创办了Camberidge Processor Unit Ltd.主营电子设备设计和制造业务。在1979年3月发明「Acorn System 1」，使用6502处理器，并将公司改名为Acorn。&lt;/li>
&lt;li>1979年6月，Intel推出8088，主频达到5~10MHz，并成功被IBM采用，作为个人电脑的处理器。&lt;/li>
&lt;li>1980年，Intel推出MCS-51单片机，内含4KB ROM，128B RAM，最初被用作IBM PC的键盘控制器。&lt;/li>
&lt;li>1981年12月，Acorn推出BBC Micro计算机，成为欧洲第一台畅销的个人计算机。并在之后开始设计一种类似高级6502架构的处理器。&lt;/li>
&lt;li>1982年，Intel推出16位单片机MCS-96系列，主频达到12MHz、8K ROM以及232B RAM，支持8级中断。&lt;/li>
&lt;li>1985年4月，Acorn公司团队研发出采用精简指令集的新处理器Acorn RISC Machine，又称ARM1，采用32位精简指令集，26位地址总线可寻址64M空间，但主频只有6MHz。&lt;/li>
&lt;li>1985年10月，Intel推出32位处理器80386，主频达到12.5-40MHz，32位地址总线可以寻址4G内存。&lt;/li>
&lt;li>1990年11月，为了更好地发展ARM，Acorn公司的12名员工接受了苹果和VLSI的投资，成立合资公司ARM，同时更改了产品策略：只负责设计，不再负责生产制造和出售，以降低研发成本和风险。&lt;/li>
&lt;li>1993年，ARM发布ARM6内核，作为ARM2和ARM3的改进版，授权给Cirrus Logic和德州仪器。同年苹果推出了的掌上电脑Newton，使用了ARM6的芯片。&lt;/li>
&lt;li>1997年，Nokia6110发布，基于ARM7TDMI内核处理器。&lt;/li>
&lt;li>2004年，ARM发布Cortex-M3内核，在ARM11后，放弃了ARMx的命名方式，并采用A、R、M系列，分别对应高性能、高实时性和微控制器场合。&lt;/li>
&lt;li>2007年，第一款iPhone发布，搭载Samsung生产的S5L8900，基于ARM11内核。&lt;/li>
&lt;li>2010年3月，任天堂在E3 2010发布了3DS，采用ARM11 MP双核和ARM9处理器。&lt;/li>
&lt;li>2017年3月，任天堂发布了Switch掌机，采用Nvidia Tegra X1处理器，基于Cortex-A57、Cortex-A53核心。&lt;/li>
&lt;li>2020年11月，苹果发布第一款基于ARM架构的自研处理器Apple M1，采用ARMv8-A指令集架构。&lt;/li>
&lt;li>2021年11月，富士通基于A64FX处理器打造的超级计算机“富岳”蝉联超算第一，采用ARMv8.2-A架构&lt;/li>
&lt;/ul>
&lt;p>早期单片机多用于外设接口控制器，服务于处理器系统， 随着芯片工艺不断改进，集成度和运算能力不断提升，微控制器也获得广泛的应用和发展。目前，比较常见的单片机有&lt;/p></description></item><item><title>异步任务队列</title><link>https://firebat.github.io/posts/async-task/</link><pubDate>Tue, 19 Apr 2022 00:00:00 -0800</pubDate><guid>https://firebat.github.io/posts/async-task/</guid><description>&lt;p>在我们介绍更复杂的调度管理问题之前，先了解一种基本的异步任务执行方案。&lt;/p>
&lt;h2 id="场景">场景&lt;/h2>
&lt;p>业务系统构建过程中，为了实现逻辑复用，面临大量的计算组装问题。如:&lt;/p>
&lt;ul>
&lt;li>数仓、复杂计算任务执行调度&lt;/li>
&lt;li>风控、营销类的策略管理&lt;/li>
&lt;li>数据核查规则管理&lt;/li>
&lt;li>多仿真验证&lt;/li>
&lt;/ul>
&lt;p>这些场景在执行时，按调用方式可以分为:&lt;/p>
&lt;ul>
&lt;li>同步组装，可以支持事务，包括节点、上下游、输入输出、常量变量定义等（择日细讲）&lt;/li>
&lt;li>异步组装，适用支持复杂流程管理，包括任务队列、优先级、回调事件等&lt;/li>
&lt;/ul>
&lt;h2 id="结构定义">结构定义&lt;/h2>
&lt;p>通过app区分，使服务可以为多个应用使用&lt;/p>
&lt;h3 id="任务队列">任务队列&lt;/h3>
&lt;ul>
&lt;li>app 应用标识&lt;/li>
&lt;li>queueId 队列标识&lt;/li>
&lt;li>queueType 队列类型, 并行=parallel, 串行=serial&lt;/li>
&lt;li>priority 优先级, 最小=0&lt;/li>
&lt;li>status 队列状态, 非激活=inactive, 激活中=active&lt;/li>
&lt;/ul>
&lt;h3 id="任务消息">任务消息&lt;/h3>
&lt;ul>
&lt;li>app 应用标识&lt;/li>
&lt;li>queueId 所属队列&lt;/li>
&lt;li>messageId 消息标识&lt;/li>
&lt;li>status 任务状态, 待执行=wait, 处理中=processing, 处理完成=completed&lt;/li>
&lt;li>taskClassName 任务类名&lt;/li>
&lt;li>parameter 任务参数&lt;/li>
&lt;li>stopQueueOnError 执行出错时，是否停止队列&lt;/li>
&lt;li>sendTime 客户发起时间&lt;/li>
&lt;li>receiveTime 服务接收时间&lt;/li>
&lt;li>acceptTime 分派时间&lt;/li>
&lt;li>startTime 开始执行时间&lt;/li>
&lt;li>nodeId 执行节点&lt;/li>
&lt;/ul>
&lt;h2 id="调度目标">调度目标&lt;/h2>
&lt;p>找到最优先需要执行的任务&lt;/p>
&lt;ul>
&lt;li>队列状态=激活中&lt;/li>
&lt;li>任务状态=待执行&lt;/li>
&lt;li>若为串型队列，只允许其中一个任务执行&lt;/li>
&lt;li>队列优先级最高&lt;/li>
&lt;li>创建时间最早&lt;/li>
&lt;/ul>
&lt;h3 id="单并行队列">单并行队列&lt;/h3>
&lt;p>每个app拥有一个并行队列(&lt;code>parallel_task_queue&lt;/code>)和多个串型队列(自定义)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">select&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t.message_id,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t.queue_id
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">from&lt;/span> task_info t
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">join&lt;/span> queue_info q &lt;span style="color:#66d9ef">on&lt;/span> q.queue_id &lt;span style="color:#f92672">=&lt;/span> t.queue_id &lt;span style="color:#66d9ef">and&lt;/span> q.status &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;active&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">where&lt;/span> t.status &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;wait&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">and&lt;/span> &lt;span style="color:#66d9ef">not&lt;/span> &lt;span style="color:#66d9ef">exists&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#66d9ef">from&lt;/span> task_info i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">where&lt;/span> i.status &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;processing&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">and&lt;/span> i.queue_id &lt;span style="color:#f92672">=&lt;/span> t.queue_id
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">and&lt;/span> i.queue_id &lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;parallel_task_queue&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">order&lt;/span> &lt;span style="color:#66d9ef">by&lt;/span> q.priority &lt;span style="color:#66d9ef">desc&lt;/span>, t.receive_time, t.id;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="多并行队列">多并行队列&lt;/h3>
&lt;p>这里给出多并行队列的筛选方法，实际上单个并行队列足够满足大多数场景。&lt;/p></description></item><item><title>存储的发展</title><link>https://firebat.github.io/posts/storage/</link><pubDate>Wed, 07 Dec 2016 00:00:00 -0800</pubDate><guid>https://firebat.github.io/posts/storage/</guid><description>&lt;h2 id="文件系统">文件系统&lt;/h2>
&lt;h3 id="professor-eggerts-dumb-file-system-1974">Professor Eggert&amp;rsquo;s Dumb File System (~1974)&lt;/h3>
&lt;p>Dr.Eggert在本科期间为了“改进UNIX”，创建了他的第一个文件系统。
&lt;img src="./images/eggertfs.png" alt="img">&lt;/p>
&lt;ul>
&lt;li>每个扇区占用512字节&lt;/li>
&lt;li>第一个扇区分成16份，用于存放文件目录&lt;/li>
&lt;li>每个目录条目包含文件名、起始位置、文件大小&lt;/li>
&lt;/ul>
&lt;p>实际上确实有几种文件系统是参照这种方案实现的，比如&lt;a href="https://en.wikipedia.org/wiki/RT-11">RT-11&lt;/a>，广泛用于实时操作系统。&lt;/p>
&lt;h3 id="fat---file-allocation-table-1977">FAT - File Allocation Table (~1977)&lt;/h3>
&lt;p>为了减少碎片化问题，引入了FAT文件分配表
&lt;img src="./images/fat.png" alt="img">&lt;/p>
&lt;ul>
&lt;li>保留地址0块，用于引导扇区&lt;/li>
&lt;li>保留地址1块，用于超级块，包含文件系统信息、版本号、根目录位置等&lt;/li>
&lt;li>每个目录条目包含文件名、扩展名、第一个块地址、文件大小、标志位等信息，目录也是文件&lt;/li>
&lt;li>链表结构，顺序访问慢（可通过碎片整理优化）&lt;/li>
&lt;/ul>
&lt;h3 id="unix-file-system-1973">Unix File System (~1973)&lt;/h3>
&lt;p>&lt;img src="./images/ufs.png" alt="img">&lt;/p>
&lt;ul>
&lt;li>引入inode管理文件索引(index node)&lt;/li>
&lt;li>树形结构&lt;/li>
&lt;/ul>
&lt;h3 id="berkeley-software-distribution-bsd">Berkeley Software Distribution (BSD)&lt;/h3>
&lt;ul>
&lt;li>1977 1BSD ex&lt;/li>
&lt;li>1978 2BSD vi, csh, berknet&lt;/li>
&lt;li>1979 3BSD VAX虚拟内存&lt;/li>
&lt;li>1980 4BSD job, TCP/IP&lt;/li>
&lt;li>1981 4.1a rcp, rsh..
&lt;img src="./images/billjoy.jpg" alt="img">
Bill Joy - BSD, Sun co-founder, vi, csh, tcp/ip, NFS&lt;/li>
&lt;/ul>
&lt;h3 id="berkeley-fast-file-system-1980-41b">Berkeley Fast File System (~1980 4.1b)&lt;/h3>
&lt;p>&lt;img src="./images/bffs.png" alt="img">&lt;/p></description></item></channel></rss>